#ifndef S11N_IMPL_VOID_TYPE_H
#define S11N_IMPL_VOID_TYPE_H

//=======================================================================================
//  Какие-то старые компиляторы дурят с типом void_t, добавлено для совместимости.
//
//  UPD 2019-09-24
//   - убрана кривая проверка, сейчас без макросни работает.
//=======================================================================================

#include <type_traits>


//=======================================================================================
namespace s11n {
namespace impl_s11n
{
    // 1. определить укуренную реализацию, которую сожрёт недо 11й компилятор.
    // 2. определить промежуточный void_type через void.
    // 3. устроить проверку промежуточному void_type.
    // 4. вывести void_type в зависимоти от проверки.

    //===================================================================================
    // 1. определить укуренную реализацию, которую сожрет недо 11й компилятор.
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-local-typedefs"
    template<class T0, class ... Ts>
    struct _void_for_old_
    {
        using v  = void;
        using _  = T0;
        using __ = _void_for_old_<Ts...>;
    };
    //-----------------------------------------------------------------------------------
    template<class T0>
    struct _void_for_old_<T0>
    {
        using v  = void;
        using _  = T0;
    };
    #pragma GCC diagnostic pop
    //===================================================================================
    // 2. определить промежуточный void_type через void.
    template<class ... Ts>
    using _may_void_type_ = void;
    //===================================================================================
    // 3. устроить проверку промежуточному void_type.
    // 3.1.a. сделать типичное применение void_type для проверки наличия метода foo();
    template<class T, class = void>
    struct _has_foo_ : public std::false_type
    {};
    //-----------------------------------------------------------------------------------
    template<class T>
    struct _has_foo_< T, _may_void_type_<decltype(std::declval<T>().foo())> >
        : public std::true_type
    {};
    //-----------------------------------------------------------------------------------
    // 3.1.b. сделать типичное применение void_type для проверки наличия метода bar();
    template<class T, class = void>
    struct _has_bar_ : public std::false_type
    {};
    //-----------------------------------------------------------------------------------
    template<class T>
    struct _has_bar_< T, _may_void_type_<decltype(std::declval<T>().bar())> >
        : public std::true_type
    {};
    //-----------------------------------------------------------------------------------
    // 3.2. вводим структуру, в которой есть только foo();
    struct _some_foo_ { void foo(); };
    //-----------------------------------------------------------------------------------
    // 3.3. проверяем как оно отработало;
    constexpr bool _may_void_is_adequate()
    {
        return _has_foo_<_some_foo_>::value &&
              !_has_bar_<_some_foo_>::value;
    }
    //===================================================================================

    //===================================================================================
    // 4. вывести vvt в зависимоти от проверки.
    template<class ... Ts>
    using void_type = typename std::conditional
        <
            impl_s11n::_may_void_is_adequate(),
            void,
            typename impl_s11n::_void_for_old_<Ts...>::v
        >::type;
    //===================================================================================
}} // namespace s11n::impl_s11n
//=======================================================================================

#endif // S11N_IMPL_VOID_TYPE_H
